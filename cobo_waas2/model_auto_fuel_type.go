/*
Cobo Wallet as a Service 2.0

Contact: help@cobo.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cobo_waas2

import (
	"encoding/json"
	"fmt"
)

// AutoFuelType The mode of transaction fee payment using Fee Station. Currently, Fee Station supports EVM-compatible and TRON transactions initiated from MPC Wallets (Organization-Controlled) and Custodial Wallets (Web3 Wallets). For more details, refer to [Fee Station](https://manuals.cobo.com/en/portal/fee-station/introduction). - `ProActiveAutoFuel`: Always use Fee Station to pay transaction fees. - `PassiveAutoFuel`: Use Fee Station only when the source address balance is insufficient to cover the transaction fees. - `UsePortalPreference`: Use payment preferences set on Cobo Portal.  Please note that the TRON chain does not support `PassiveAutoFuel` due to its fee delegation mechanism. 
type AutoFuelType string

// List of AutoFuelType
const (
	AUTOFUELTYPE_PASSIVE_AUTO_FUEL AutoFuelType = "PassiveAutoFuel"
	AUTOFUELTYPE_PRO_ACTIVE_AUTO_FUEL AutoFuelType = "ProActiveAutoFuel"
	AUTOFUELTYPE_USE_PORTAL_PREFERENCE AutoFuelType = "UsePortalPreference"
)

// All allowed values of AutoFuelType enum
var AllowedAutoFuelTypeEnumValues = []AutoFuelType{
	"PassiveAutoFuel",
	"ProActiveAutoFuel",
	"UsePortalPreference",
}

func (v *AutoFuelType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := AutoFuelType(value)
	for _, existing := range AllowedAutoFuelTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}
	*v = AutoFuelType("unknown")
	return nil
}

// NewAutoFuelTypeFromValue returns a pointer to a valid AutoFuelType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewAutoFuelTypeFromValue(v string) (*AutoFuelType, error) {
	ev := AutoFuelType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for AutoFuelType: valid values are %v", v, AllowedAutoFuelTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v AutoFuelType) IsValid() bool {
	for _, existing := range AllowedAutoFuelTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to AutoFuelType value
func (v AutoFuelType) Ptr() *AutoFuelType {
	return &v
}

type NullableAutoFuelType struct {
	value *AutoFuelType
	isSet bool
}

func (v NullableAutoFuelType) Get() *AutoFuelType {
	return v.value
}

func (v *NullableAutoFuelType) Set(val *AutoFuelType) {
	v.value = val
	v.isSet = true
}

func (v NullableAutoFuelType) IsSet() bool {
	return v.isSet
}

func (v *NullableAutoFuelType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableAutoFuelType(val *AutoFuelType) *NullableAutoFuelType {
	return &NullableAutoFuelType{value: val, isSet: true}
}

func (v NullableAutoFuelType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableAutoFuelType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

