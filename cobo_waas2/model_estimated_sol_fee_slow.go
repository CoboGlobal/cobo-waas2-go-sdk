/*
Cobo Wallet as a Service 2.0

Contact: help@cobo.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cobo_waas2

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the EstimatedSOLFeeSlow type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &EstimatedSOLFeeSlow{}

// EstimatedSOLFeeSlow struct for EstimatedSOLFeeSlow
type EstimatedSOLFeeSlow struct {
	// The cost per compute unit. Transactions consume computational resources measured in compute units, and this price helps determine the cost of executing transactions, especially complex ones involving smart contracts.
	ComputeUnitPrice string `json:"compute_unit_price"`
	// The maximum number of compute units allowed for a transaction. This limits the resources any single transaction can consume, preventing excessive resource usage that could impact network performance negatively.
	ComputeUnitLimit string `json:"compute_unit_limit"`
	// The fundamental fee required for each transaction. It is charged to prevent spam transactions and network congestion, ensuring that only meaningful transactions consume network resources.
	BaseFee string `json:"base_fee"`
	// The fee charged as rent for maintaining the state of accounts on the blockchain. This rent ensures accounts are stored on-chain over the long term and that there's sufficient balance to sustain the account state.
	RentAmount *string `json:"rent_amount,omitempty"`
}

type _EstimatedSOLFeeSlow EstimatedSOLFeeSlow

// NewEstimatedSOLFeeSlow instantiates a new EstimatedSOLFeeSlow object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewEstimatedSOLFeeSlow(computeUnitPrice string, computeUnitLimit string, baseFee string) *EstimatedSOLFeeSlow {
	this := EstimatedSOLFeeSlow{}
	this.ComputeUnitPrice = computeUnitPrice
	this.ComputeUnitLimit = computeUnitLimit
	this.BaseFee = baseFee
	return &this
}

// NewEstimatedSOLFeeSlowWithDefaults instantiates a new EstimatedSOLFeeSlow object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewEstimatedSOLFeeSlowWithDefaults() *EstimatedSOLFeeSlow {
	this := EstimatedSOLFeeSlow{}
	return &this
}

// GetComputeUnitPrice returns the ComputeUnitPrice field value
func (o *EstimatedSOLFeeSlow) GetComputeUnitPrice() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.ComputeUnitPrice
}

// GetComputeUnitPriceOk returns a tuple with the ComputeUnitPrice field value
// and a boolean to check if the value has been set.
func (o *EstimatedSOLFeeSlow) GetComputeUnitPriceOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ComputeUnitPrice, true
}

// SetComputeUnitPrice sets field value
func (o *EstimatedSOLFeeSlow) SetComputeUnitPrice(v string) {
	o.ComputeUnitPrice = v
}

// GetComputeUnitLimit returns the ComputeUnitLimit field value
func (o *EstimatedSOLFeeSlow) GetComputeUnitLimit() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.ComputeUnitLimit
}

// GetComputeUnitLimitOk returns a tuple with the ComputeUnitLimit field value
// and a boolean to check if the value has been set.
func (o *EstimatedSOLFeeSlow) GetComputeUnitLimitOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ComputeUnitLimit, true
}

// SetComputeUnitLimit sets field value
func (o *EstimatedSOLFeeSlow) SetComputeUnitLimit(v string) {
	o.ComputeUnitLimit = v
}

// GetBaseFee returns the BaseFee field value
func (o *EstimatedSOLFeeSlow) GetBaseFee() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.BaseFee
}

// GetBaseFeeOk returns a tuple with the BaseFee field value
// and a boolean to check if the value has been set.
func (o *EstimatedSOLFeeSlow) GetBaseFeeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.BaseFee, true
}

// SetBaseFee sets field value
func (o *EstimatedSOLFeeSlow) SetBaseFee(v string) {
	o.BaseFee = v
}

// GetRentAmount returns the RentAmount field value if set, zero value otherwise.
func (o *EstimatedSOLFeeSlow) GetRentAmount() string {
	if o == nil || IsNil(o.RentAmount) {
		var ret string
		return ret
	}
	return *o.RentAmount
}

// GetRentAmountOk returns a tuple with the RentAmount field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *EstimatedSOLFeeSlow) GetRentAmountOk() (*string, bool) {
	if o == nil || IsNil(o.RentAmount) {
		return nil, false
	}
	return o.RentAmount, true
}

// HasRentAmount returns a boolean if a field has been set.
func (o *EstimatedSOLFeeSlow) HasRentAmount() bool {
	if o != nil && !IsNil(o.RentAmount) {
		return true
	}

	return false
}

// SetRentAmount gets a reference to the given string and assigns it to the RentAmount field.
func (o *EstimatedSOLFeeSlow) SetRentAmount(v string) {
	o.RentAmount = &v
}

func (o EstimatedSOLFeeSlow) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o EstimatedSOLFeeSlow) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["compute_unit_price"] = o.ComputeUnitPrice
	toSerialize["compute_unit_limit"] = o.ComputeUnitLimit
	toSerialize["base_fee"] = o.BaseFee
	if !IsNil(o.RentAmount) {
		toSerialize["rent_amount"] = o.RentAmount
	}
	return toSerialize, nil
}

func (o *EstimatedSOLFeeSlow) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"compute_unit_price",
		"compute_unit_limit",
		"base_fee",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varEstimatedSOLFeeSlow := _EstimatedSOLFeeSlow{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	//decoder.DisallowUnknownFields()
	err = decoder.Decode(&varEstimatedSOLFeeSlow)

	if err != nil {
		return err
	}

	*o = EstimatedSOLFeeSlow(varEstimatedSOLFeeSlow)

	return err
}

type NullableEstimatedSOLFeeSlow struct {
	value *EstimatedSOLFeeSlow
	isSet bool
}

func (v NullableEstimatedSOLFeeSlow) Get() *EstimatedSOLFeeSlow {
	return v.value
}

func (v *NullableEstimatedSOLFeeSlow) Set(val *EstimatedSOLFeeSlow) {
	v.value = val
	v.isSet = true
}

func (v NullableEstimatedSOLFeeSlow) IsSet() bool {
	return v.isSet
}

func (v *NullableEstimatedSOLFeeSlow) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableEstimatedSOLFeeSlow(val *EstimatedSOLFeeSlow) *NullableEstimatedSOLFeeSlow {
	return &NullableEstimatedSOLFeeSlow{value: val, isSet: true}
}

func (v NullableEstimatedSOLFeeSlow) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableEstimatedSOLFeeSlow) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


