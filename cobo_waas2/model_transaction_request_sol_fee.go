/*
Cobo Wallet as a Service 2.0

Contact: help@cobo.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cobo_waas2

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the TransactionRequestSOLFee type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &TransactionRequestSOLFee{}

// TransactionRequestSOLFee The preset properties to limit transaction fee.  In the Solana fee model, the transaction fee is calculated by adding the base fee to the product of the compute unit limit and the compute unit price. This can be expressed as: Transaction fee = base fee + (CU limit * CU price). For more information about the Solana fee model, refer to [Fee models](https://www.cobo.com/developers/v2/guides/transactions/estimate-fees#fee-models).  You can specify CU price and CU limit to adjust the priority and resource allocation of your transaction.  Switch between the tabs to display the properties for different transaction fee models. 
type TransactionRequestSOLFee struct {
	// The price paid per compute unit. This value determines the priority fee for the transaction, allowing you to increase inclusion probability in congested conditions.
	ComputeUnitPrice string `json:"compute_unit_price"`
	// The maximum number of compute units your transaction is allowed to consume. It sets an upper bound on computational resource usage to prevent overload.
	ComputeUnitLimit string `json:"compute_unit_limit"`
	FeeType FeeType `json:"fee_type"`
	// The token used to pay the transaction fee.
	TokenId string `json:"token_id"`
}

type _TransactionRequestSOLFee TransactionRequestSOLFee

// NewTransactionRequestSOLFee instantiates a new TransactionRequestSOLFee object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewTransactionRequestSOLFee(computeUnitPrice string, computeUnitLimit string, feeType FeeType, tokenId string) *TransactionRequestSOLFee {
	this := TransactionRequestSOLFee{}
	this.ComputeUnitPrice = computeUnitPrice
	this.ComputeUnitLimit = computeUnitLimit
	this.FeeType = feeType
	this.TokenId = tokenId
	return &this
}

// NewTransactionRequestSOLFeeWithDefaults instantiates a new TransactionRequestSOLFee object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewTransactionRequestSOLFeeWithDefaults() *TransactionRequestSOLFee {
	this := TransactionRequestSOLFee{}
	var feeType FeeType = FEETYPE_EVM_EIP_1559
	this.FeeType = feeType
	return &this
}

// GetComputeUnitPrice returns the ComputeUnitPrice field value
func (o *TransactionRequestSOLFee) GetComputeUnitPrice() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.ComputeUnitPrice
}

// GetComputeUnitPriceOk returns a tuple with the ComputeUnitPrice field value
// and a boolean to check if the value has been set.
func (o *TransactionRequestSOLFee) GetComputeUnitPriceOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ComputeUnitPrice, true
}

// SetComputeUnitPrice sets field value
func (o *TransactionRequestSOLFee) SetComputeUnitPrice(v string) {
	o.ComputeUnitPrice = v
}

// GetComputeUnitLimit returns the ComputeUnitLimit field value
func (o *TransactionRequestSOLFee) GetComputeUnitLimit() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.ComputeUnitLimit
}

// GetComputeUnitLimitOk returns a tuple with the ComputeUnitLimit field value
// and a boolean to check if the value has been set.
func (o *TransactionRequestSOLFee) GetComputeUnitLimitOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ComputeUnitLimit, true
}

// SetComputeUnitLimit sets field value
func (o *TransactionRequestSOLFee) SetComputeUnitLimit(v string) {
	o.ComputeUnitLimit = v
}

// GetFeeType returns the FeeType field value
func (o *TransactionRequestSOLFee) GetFeeType() FeeType {
	if o == nil {
		var ret FeeType
		return ret
	}

	return o.FeeType
}

// GetFeeTypeOk returns a tuple with the FeeType field value
// and a boolean to check if the value has been set.
func (o *TransactionRequestSOLFee) GetFeeTypeOk() (*FeeType, bool) {
	if o == nil {
		return nil, false
	}
	return &o.FeeType, true
}

// SetFeeType sets field value
func (o *TransactionRequestSOLFee) SetFeeType(v FeeType) {
	o.FeeType = v
}

// GetTokenId returns the TokenId field value
func (o *TransactionRequestSOLFee) GetTokenId() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.TokenId
}

// GetTokenIdOk returns a tuple with the TokenId field value
// and a boolean to check if the value has been set.
func (o *TransactionRequestSOLFee) GetTokenIdOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.TokenId, true
}

// SetTokenId sets field value
func (o *TransactionRequestSOLFee) SetTokenId(v string) {
	o.TokenId = v
}

func (o TransactionRequestSOLFee) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o TransactionRequestSOLFee) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["compute_unit_price"] = o.ComputeUnitPrice
	toSerialize["compute_unit_limit"] = o.ComputeUnitLimit
	toSerialize["fee_type"] = o.FeeType
	toSerialize["token_id"] = o.TokenId
	return toSerialize, nil
}

func (o *TransactionRequestSOLFee) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"compute_unit_price",
		"compute_unit_limit",
		"fee_type",
		"token_id",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varTransactionRequestSOLFee := _TransactionRequestSOLFee{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	//decoder.DisallowUnknownFields()
	err = decoder.Decode(&varTransactionRequestSOLFee)

	if err != nil {
		return err
	}

	*o = TransactionRequestSOLFee(varTransactionRequestSOLFee)

	return err
}

type NullableTransactionRequestSOLFee struct {
	value *TransactionRequestSOLFee
	isSet bool
}

func (v NullableTransactionRequestSOLFee) Get() *TransactionRequestSOLFee {
	return v.value
}

func (v *NullableTransactionRequestSOLFee) Set(val *TransactionRequestSOLFee) {
	v.value = val
	v.isSet = true
}

func (v NullableTransactionRequestSOLFee) IsSet() bool {
	return v.isSet
}

func (v *NullableTransactionRequestSOLFee) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTransactionRequestSOLFee(val *TransactionRequestSOLFee) *NullableTransactionRequestSOLFee {
	return &NullableTransactionRequestSOLFee{value: val, isSet: true}
}

func (v NullableTransactionRequestSOLFee) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTransactionRequestSOLFee) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


