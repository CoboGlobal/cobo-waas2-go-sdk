/*
Cobo Wallet as a Service 2.0

Contact: help@cobo.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cobo_waas2

import (
	"encoding/json"
	"fmt"
)

// WebhookEventData - struct for WebhookEventData
type WebhookEventData struct {
	AddressesEventData *AddressesEventData
	BalanceUpdateInfoEventData *BalanceUpdateInfoEventData
	ChainsEventData *ChainsEventData
	MPCVaultEventData *MPCVaultEventData
	PaymentOrderEventData *PaymentOrderEventData
	PaymentRefundEventData *PaymentRefundEventData
	PaymentSettlementEvent *PaymentSettlementEvent
	SuspendedTokenEventData *SuspendedTokenEventData
	TSSRequestWebhookEventData *TSSRequestWebhookEventData
	TokenListingEventData *TokenListingEventData
	TokensEventData *TokensEventData
	TransactionWebhookEventData *TransactionWebhookEventData
	WalletInfoEventData *WalletInfoEventData
}

// AddressesEventDataAsWebhookEventData is a convenience function that returns AddressesEventData wrapped in WebhookEventData
func AddressesEventDataAsWebhookEventData(v *AddressesEventData) WebhookEventData {
	return WebhookEventData{
		AddressesEventData: v,
	}
}

// BalanceUpdateInfoEventDataAsWebhookEventData is a convenience function that returns BalanceUpdateInfoEventData wrapped in WebhookEventData
func BalanceUpdateInfoEventDataAsWebhookEventData(v *BalanceUpdateInfoEventData) WebhookEventData {
	return WebhookEventData{
		BalanceUpdateInfoEventData: v,
	}
}

// ChainsEventDataAsWebhookEventData is a convenience function that returns ChainsEventData wrapped in WebhookEventData
func ChainsEventDataAsWebhookEventData(v *ChainsEventData) WebhookEventData {
	return WebhookEventData{
		ChainsEventData: v,
	}
}

// MPCVaultEventDataAsWebhookEventData is a convenience function that returns MPCVaultEventData wrapped in WebhookEventData
func MPCVaultEventDataAsWebhookEventData(v *MPCVaultEventData) WebhookEventData {
	return WebhookEventData{
		MPCVaultEventData: v,
	}
}

// PaymentOrderEventDataAsWebhookEventData is a convenience function that returns PaymentOrderEventData wrapped in WebhookEventData
func PaymentOrderEventDataAsWebhookEventData(v *PaymentOrderEventData) WebhookEventData {
	return WebhookEventData{
		PaymentOrderEventData: v,
	}
}

// PaymentRefundEventDataAsWebhookEventData is a convenience function that returns PaymentRefundEventData wrapped in WebhookEventData
func PaymentRefundEventDataAsWebhookEventData(v *PaymentRefundEventData) WebhookEventData {
	return WebhookEventData{
		PaymentRefundEventData: v,
	}
}

// PaymentSettlementEventAsWebhookEventData is a convenience function that returns PaymentSettlementEvent wrapped in WebhookEventData
func PaymentSettlementEventAsWebhookEventData(v *PaymentSettlementEvent) WebhookEventData {
	return WebhookEventData{
		PaymentSettlementEvent: v,
	}
}

// SuspendedTokenEventDataAsWebhookEventData is a convenience function that returns SuspendedTokenEventData wrapped in WebhookEventData
func SuspendedTokenEventDataAsWebhookEventData(v *SuspendedTokenEventData) WebhookEventData {
	return WebhookEventData{
		SuspendedTokenEventData: v,
	}
}

// TSSRequestWebhookEventDataAsWebhookEventData is a convenience function that returns TSSRequestWebhookEventData wrapped in WebhookEventData
func TSSRequestWebhookEventDataAsWebhookEventData(v *TSSRequestWebhookEventData) WebhookEventData {
	return WebhookEventData{
		TSSRequestWebhookEventData: v,
	}
}

// TokenListingEventDataAsWebhookEventData is a convenience function that returns TokenListingEventData wrapped in WebhookEventData
func TokenListingEventDataAsWebhookEventData(v *TokenListingEventData) WebhookEventData {
	return WebhookEventData{
		TokenListingEventData: v,
	}
}

// TokensEventDataAsWebhookEventData is a convenience function that returns TokensEventData wrapped in WebhookEventData
func TokensEventDataAsWebhookEventData(v *TokensEventData) WebhookEventData {
	return WebhookEventData{
		TokensEventData: v,
	}
}

// TransactionWebhookEventDataAsWebhookEventData is a convenience function that returns TransactionWebhookEventData wrapped in WebhookEventData
func TransactionWebhookEventDataAsWebhookEventData(v *TransactionWebhookEventData) WebhookEventData {
	return WebhookEventData{
		TransactionWebhookEventData: v,
	}
}

// WalletInfoEventDataAsWebhookEventData is a convenience function that returns WalletInfoEventData wrapped in WebhookEventData
func WalletInfoEventDataAsWebhookEventData(v *WalletInfoEventData) WebhookEventData {
	return WebhookEventData{
		WalletInfoEventData: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *WebhookEventData) UnmarshalJSON(data []byte) error {
	var err error
	// use discriminator value to speed up the lookup
	var jsonDict map[string]interface{}
	err = newStrictDecoder(data).Decode(&jsonDict)
	if err != nil {
		return fmt.Errorf("failed to unmarshal JSON into map for the discriminator lookup")
	}

	// check if the discriminator value is 'Addresses'
	if jsonDict["data_type"] == "Addresses" {
		// try to unmarshal JSON data into AddressesEventData
		err = json.Unmarshal(data, &dst.AddressesEventData)
		if err == nil {
			return nil // data stored in dst.AddressesEventData, return on the first match
		} else {
			dst.AddressesEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as AddressesEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'BalanceUpdateInfo'
	if jsonDict["data_type"] == "BalanceUpdateInfo" {
		// try to unmarshal JSON data into BalanceUpdateInfoEventData
		err = json.Unmarshal(data, &dst.BalanceUpdateInfoEventData)
		if err == nil {
			return nil // data stored in dst.BalanceUpdateInfoEventData, return on the first match
		} else {
			dst.BalanceUpdateInfoEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as BalanceUpdateInfoEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'Chains'
	if jsonDict["data_type"] == "Chains" {
		// try to unmarshal JSON data into ChainsEventData
		err = json.Unmarshal(data, &dst.ChainsEventData)
		if err == nil {
			return nil // data stored in dst.ChainsEventData, return on the first match
		} else {
			dst.ChainsEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as ChainsEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'MPCVault'
	if jsonDict["data_type"] == "MPCVault" {
		// try to unmarshal JSON data into MPCVaultEventData
		err = json.Unmarshal(data, &dst.MPCVaultEventData)
		if err == nil {
			return nil // data stored in dst.MPCVaultEventData, return on the first match
		} else {
			dst.MPCVaultEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as MPCVaultEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'PaymentOrder'
	if jsonDict["data_type"] == "PaymentOrder" {
		// try to unmarshal JSON data into PaymentOrderEventData
		err = json.Unmarshal(data, &dst.PaymentOrderEventData)
		if err == nil {
			return nil // data stored in dst.PaymentOrderEventData, return on the first match
		} else {
			dst.PaymentOrderEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as PaymentOrderEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'PaymentRefund'
	if jsonDict["data_type"] == "PaymentRefund" {
		// try to unmarshal JSON data into PaymentRefundEventData
		err = json.Unmarshal(data, &dst.PaymentRefundEventData)
		if err == nil {
			return nil // data stored in dst.PaymentRefundEventData, return on the first match
		} else {
			dst.PaymentRefundEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as PaymentRefundEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'PaymentSettlement'
	if jsonDict["data_type"] == "PaymentSettlement" {
		// try to unmarshal JSON data into PaymentSettlementEvent
		err = json.Unmarshal(data, &dst.PaymentSettlementEvent)
		if err == nil {
			return nil // data stored in dst.PaymentSettlementEvent, return on the first match
		} else {
			dst.PaymentSettlementEvent = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as PaymentSettlementEvent: %s", err.Error())
		}
	}

	// check if the discriminator value is 'SuspendedToken'
	if jsonDict["data_type"] == "SuspendedToken" {
		// try to unmarshal JSON data into SuspendedTokenEventData
		err = json.Unmarshal(data, &dst.SuspendedTokenEventData)
		if err == nil {
			return nil // data stored in dst.SuspendedTokenEventData, return on the first match
		} else {
			dst.SuspendedTokenEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as SuspendedTokenEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'TSSRequest'
	if jsonDict["data_type"] == "TSSRequest" {
		// try to unmarshal JSON data into TSSRequestWebhookEventData
		err = json.Unmarshal(data, &dst.TSSRequestWebhookEventData)
		if err == nil {
			return nil // data stored in dst.TSSRequestWebhookEventData, return on the first match
		} else {
			dst.TSSRequestWebhookEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as TSSRequestWebhookEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'TokenListing'
	if jsonDict["data_type"] == "TokenListing" {
		// try to unmarshal JSON data into TokenListingEventData
		err = json.Unmarshal(data, &dst.TokenListingEventData)
		if err == nil {
			return nil // data stored in dst.TokenListingEventData, return on the first match
		} else {
			dst.TokenListingEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as TokenListingEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'Tokens'
	if jsonDict["data_type"] == "Tokens" {
		// try to unmarshal JSON data into TokensEventData
		err = json.Unmarshal(data, &dst.TokensEventData)
		if err == nil {
			return nil // data stored in dst.TokensEventData, return on the first match
		} else {
			dst.TokensEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as TokensEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'Transaction'
	if jsonDict["data_type"] == "Transaction" {
		// try to unmarshal JSON data into TransactionWebhookEventData
		err = json.Unmarshal(data, &dst.TransactionWebhookEventData)
		if err == nil {
			return nil // data stored in dst.TransactionWebhookEventData, return on the first match
		} else {
			dst.TransactionWebhookEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as TransactionWebhookEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'WalletInfo'
	if jsonDict["data_type"] == "WalletInfo" {
		// try to unmarshal JSON data into WalletInfoEventData
		err = json.Unmarshal(data, &dst.WalletInfoEventData)
		if err == nil {
			return nil // data stored in dst.WalletInfoEventData, return on the first match
		} else {
			dst.WalletInfoEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as WalletInfoEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'AddressesEventData'
	if jsonDict["data_type"] == "AddressesEventData" {
		// try to unmarshal JSON data into AddressesEventData
		err = json.Unmarshal(data, &dst.AddressesEventData)
		if err == nil {
			return nil // data stored in dst.AddressesEventData, return on the first match
		} else {
			dst.AddressesEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as AddressesEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'BalanceUpdateInfoEventData'
	if jsonDict["data_type"] == "BalanceUpdateInfoEventData" {
		// try to unmarshal JSON data into BalanceUpdateInfoEventData
		err = json.Unmarshal(data, &dst.BalanceUpdateInfoEventData)
		if err == nil {
			return nil // data stored in dst.BalanceUpdateInfoEventData, return on the first match
		} else {
			dst.BalanceUpdateInfoEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as BalanceUpdateInfoEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'ChainsEventData'
	if jsonDict["data_type"] == "ChainsEventData" {
		// try to unmarshal JSON data into ChainsEventData
		err = json.Unmarshal(data, &dst.ChainsEventData)
		if err == nil {
			return nil // data stored in dst.ChainsEventData, return on the first match
		} else {
			dst.ChainsEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as ChainsEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'MPCVaultEventData'
	if jsonDict["data_type"] == "MPCVaultEventData" {
		// try to unmarshal JSON data into MPCVaultEventData
		err = json.Unmarshal(data, &dst.MPCVaultEventData)
		if err == nil {
			return nil // data stored in dst.MPCVaultEventData, return on the first match
		} else {
			dst.MPCVaultEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as MPCVaultEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'PaymentOrderEventData'
	if jsonDict["data_type"] == "PaymentOrderEventData" {
		// try to unmarshal JSON data into PaymentOrderEventData
		err = json.Unmarshal(data, &dst.PaymentOrderEventData)
		if err == nil {
			return nil // data stored in dst.PaymentOrderEventData, return on the first match
		} else {
			dst.PaymentOrderEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as PaymentOrderEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'PaymentRefundEventData'
	if jsonDict["data_type"] == "PaymentRefundEventData" {
		// try to unmarshal JSON data into PaymentRefundEventData
		err = json.Unmarshal(data, &dst.PaymentRefundEventData)
		if err == nil {
			return nil // data stored in dst.PaymentRefundEventData, return on the first match
		} else {
			dst.PaymentRefundEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as PaymentRefundEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'PaymentSettlementEvent'
	if jsonDict["data_type"] == "PaymentSettlementEvent" {
		// try to unmarshal JSON data into PaymentSettlementEvent
		err = json.Unmarshal(data, &dst.PaymentSettlementEvent)
		if err == nil {
			return nil // data stored in dst.PaymentSettlementEvent, return on the first match
		} else {
			dst.PaymentSettlementEvent = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as PaymentSettlementEvent: %s", err.Error())
		}
	}

	// check if the discriminator value is 'SuspendedTokenEventData'
	if jsonDict["data_type"] == "SuspendedTokenEventData" {
		// try to unmarshal JSON data into SuspendedTokenEventData
		err = json.Unmarshal(data, &dst.SuspendedTokenEventData)
		if err == nil {
			return nil // data stored in dst.SuspendedTokenEventData, return on the first match
		} else {
			dst.SuspendedTokenEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as SuspendedTokenEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'TSSRequestWebhookEventData'
	if jsonDict["data_type"] == "TSSRequestWebhookEventData" {
		// try to unmarshal JSON data into TSSRequestWebhookEventData
		err = json.Unmarshal(data, &dst.TSSRequestWebhookEventData)
		if err == nil {
			return nil // data stored in dst.TSSRequestWebhookEventData, return on the first match
		} else {
			dst.TSSRequestWebhookEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as TSSRequestWebhookEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'TokenListingEventData'
	if jsonDict["data_type"] == "TokenListingEventData" {
		// try to unmarshal JSON data into TokenListingEventData
		err = json.Unmarshal(data, &dst.TokenListingEventData)
		if err == nil {
			return nil // data stored in dst.TokenListingEventData, return on the first match
		} else {
			dst.TokenListingEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as TokenListingEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'TokensEventData'
	if jsonDict["data_type"] == "TokensEventData" {
		// try to unmarshal JSON data into TokensEventData
		err = json.Unmarshal(data, &dst.TokensEventData)
		if err == nil {
			return nil // data stored in dst.TokensEventData, return on the first match
		} else {
			dst.TokensEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as TokensEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'TransactionWebhookEventData'
	if jsonDict["data_type"] == "TransactionWebhookEventData" {
		// try to unmarshal JSON data into TransactionWebhookEventData
		err = json.Unmarshal(data, &dst.TransactionWebhookEventData)
		if err == nil {
			return nil // data stored in dst.TransactionWebhookEventData, return on the first match
		} else {
			dst.TransactionWebhookEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as TransactionWebhookEventData: %s", err.Error())
		}
	}

	// check if the discriminator value is 'WalletInfoEventData'
	if jsonDict["data_type"] == "WalletInfoEventData" {
		// try to unmarshal JSON data into WalletInfoEventData
		err = json.Unmarshal(data, &dst.WalletInfoEventData)
		if err == nil {
			return nil // data stored in dst.WalletInfoEventData, return on the first match
		} else {
			dst.WalletInfoEventData = nil
			return fmt.Errorf("failed to unmarshal WebhookEventData as WalletInfoEventData: %s", err.Error())
		}
	}

	return nil
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src WebhookEventData) MarshalJSON() ([]byte, error) {
	if src.AddressesEventData != nil {
		return json.Marshal(&src.AddressesEventData)
	}

	if src.BalanceUpdateInfoEventData != nil {
		return json.Marshal(&src.BalanceUpdateInfoEventData)
	}

	if src.ChainsEventData != nil {
		return json.Marshal(&src.ChainsEventData)
	}

	if src.MPCVaultEventData != nil {
		return json.Marshal(&src.MPCVaultEventData)
	}

	if src.PaymentOrderEventData != nil {
		return json.Marshal(&src.PaymentOrderEventData)
	}

	if src.PaymentRefundEventData != nil {
		return json.Marshal(&src.PaymentRefundEventData)
	}

	if src.PaymentSettlementEvent != nil {
		return json.Marshal(&src.PaymentSettlementEvent)
	}

	if src.SuspendedTokenEventData != nil {
		return json.Marshal(&src.SuspendedTokenEventData)
	}

	if src.TSSRequestWebhookEventData != nil {
		return json.Marshal(&src.TSSRequestWebhookEventData)
	}

	if src.TokenListingEventData != nil {
		return json.Marshal(&src.TokenListingEventData)
	}

	if src.TokensEventData != nil {
		return json.Marshal(&src.TokensEventData)
	}

	if src.TransactionWebhookEventData != nil {
		return json.Marshal(&src.TransactionWebhookEventData)
	}

	if src.WalletInfoEventData != nil {
		return json.Marshal(&src.WalletInfoEventData)
	}

	return []byte(`{}`), nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *WebhookEventData) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.AddressesEventData != nil {
		return obj.AddressesEventData
	}

	if obj.BalanceUpdateInfoEventData != nil {
		return obj.BalanceUpdateInfoEventData
	}

	if obj.ChainsEventData != nil {
		return obj.ChainsEventData
	}

	if obj.MPCVaultEventData != nil {
		return obj.MPCVaultEventData
	}

	if obj.PaymentOrderEventData != nil {
		return obj.PaymentOrderEventData
	}

	if obj.PaymentRefundEventData != nil {
		return obj.PaymentRefundEventData
	}

	if obj.PaymentSettlementEvent != nil {
		return obj.PaymentSettlementEvent
	}

	if obj.SuspendedTokenEventData != nil {
		return obj.SuspendedTokenEventData
	}

	if obj.TSSRequestWebhookEventData != nil {
		return obj.TSSRequestWebhookEventData
	}

	if obj.TokenListingEventData != nil {
		return obj.TokenListingEventData
	}

	if obj.TokensEventData != nil {
		return obj.TokensEventData
	}

	if obj.TransactionWebhookEventData != nil {
		return obj.TransactionWebhookEventData
	}

	if obj.WalletInfoEventData != nil {
		return obj.WalletInfoEventData
	}

	// all schemas are nil
	return nil
}

type NullableWebhookEventData struct {
	value *WebhookEventData
	isSet bool
}

func (v NullableWebhookEventData) Get() *WebhookEventData {
	return v.value
}

func (v *NullableWebhookEventData) Set(val *WebhookEventData) {
	v.value = val
	v.isSet = true
}

func (v NullableWebhookEventData) IsSet() bool {
	return v.isSet
}

func (v *NullableWebhookEventData) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableWebhookEventData(val *WebhookEventData) *NullableWebhookEventData {
	return &NullableWebhookEventData{value: val, isSet: true}
}

func (v NullableWebhookEventData) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableWebhookEventData) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


