/*
Cobo Wallet as a Service 2.0

API version: 1.0.0
Contact: support@cobo.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package CoboWaas2

import (
	"encoding/json"
	"fmt"
)

// TransactionSource - struct for TransactionSource
type TransactionSource struct {
	TransactionAddressSource *TransactionAddressSource
	TransactionCustodialWalletSource *TransactionCustodialWalletSource
	TransactionExchangeWalletSource *TransactionExchangeWalletSource
	TransactionFeeStationWalletSource *TransactionFeeStationWalletSource
	TransactionMPCWalletSource *TransactionMPCWalletSource
	TransactionSafeWalletSource *TransactionSafeWalletSource
}

// TransactionAddressSourceAsTransactionSource is a convenience function that returns TransactionAddressSource wrapped in TransactionSource
func TransactionAddressSourceAsTransactionSource(v *TransactionAddressSource) TransactionSource {
	return TransactionSource{
		TransactionAddressSource: v,
	}
}

// TransactionCustodialWalletSourceAsTransactionSource is a convenience function that returns TransactionCustodialWalletSource wrapped in TransactionSource
func TransactionCustodialWalletSourceAsTransactionSource(v *TransactionCustodialWalletSource) TransactionSource {
	return TransactionSource{
		TransactionCustodialWalletSource: v,
	}
}

// TransactionExchangeWalletSourceAsTransactionSource is a convenience function that returns TransactionExchangeWalletSource wrapped in TransactionSource
func TransactionExchangeWalletSourceAsTransactionSource(v *TransactionExchangeWalletSource) TransactionSource {
	return TransactionSource{
		TransactionExchangeWalletSource: v,
	}
}

// TransactionFeeStationWalletSourceAsTransactionSource is a convenience function that returns TransactionFeeStationWalletSource wrapped in TransactionSource
func TransactionFeeStationWalletSourceAsTransactionSource(v *TransactionFeeStationWalletSource) TransactionSource {
	return TransactionSource{
		TransactionFeeStationWalletSource: v,
	}
}

// TransactionMPCWalletSourceAsTransactionSource is a convenience function that returns TransactionMPCWalletSource wrapped in TransactionSource
func TransactionMPCWalletSourceAsTransactionSource(v *TransactionMPCWalletSource) TransactionSource {
	return TransactionSource{
		TransactionMPCWalletSource: v,
	}
}

// TransactionSafeWalletSourceAsTransactionSource is a convenience function that returns TransactionSafeWalletSource wrapped in TransactionSource
func TransactionSafeWalletSourceAsTransactionSource(v *TransactionSafeWalletSource) TransactionSource {
	return TransactionSource{
		TransactionSafeWalletSource: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *TransactionSource) UnmarshalJSON(data []byte) error {
	var err error
	// use discriminator value to speed up the lookup
	var jsonDict map[string]interface{}
	err = newStrictDecoder(data).Decode(&jsonDict)
	if err != nil {
		return fmt.Errorf("failed to unmarshal JSON into map for the discriminator lookup")
	}

	// check if the discriminator value is 'Address'
	if jsonDict["source_type"] == "Address" {
		// try to unmarshal JSON data into TransactionAddressSource
		err = json.Unmarshal(data, &dst.TransactionAddressSource)
		if err == nil {
			return nil // data stored in dst.TransactionAddressSource, return on the first match
		} else {
			dst.TransactionAddressSource = nil
			return fmt.Errorf("failed to unmarshal TransactionSource as TransactionAddressSource: %s", err.Error())
		}
	}

	// check if the discriminator value is 'CustodialWallet'
	if jsonDict["source_type"] == "CustodialWallet" {
		// try to unmarshal JSON data into TransactionCustodialWalletSource
		err = json.Unmarshal(data, &dst.TransactionCustodialWalletSource)
		if err == nil {
			return nil // data stored in dst.TransactionCustodialWalletSource, return on the first match
		} else {
			dst.TransactionCustodialWalletSource = nil
			return fmt.Errorf("failed to unmarshal TransactionSource as TransactionCustodialWalletSource: %s", err.Error())
		}
	}

	// check if the discriminator value is 'ExchangeWallet'
	if jsonDict["source_type"] == "ExchangeWallet" {
		// try to unmarshal JSON data into TransactionExchangeWalletSource
		err = json.Unmarshal(data, &dst.TransactionExchangeWalletSource)
		if err == nil {
			return nil // data stored in dst.TransactionExchangeWalletSource, return on the first match
		} else {
			dst.TransactionExchangeWalletSource = nil
			return fmt.Errorf("failed to unmarshal TransactionSource as TransactionExchangeWalletSource: %s", err.Error())
		}
	}

	// check if the discriminator value is 'FeeStation'
	if jsonDict["source_type"] == "FeeStation" {
		// try to unmarshal JSON data into TransactionFeeStationWalletSource
		err = json.Unmarshal(data, &dst.TransactionFeeStationWalletSource)
		if err == nil {
			return nil // data stored in dst.TransactionFeeStationWalletSource, return on the first match
		} else {
			dst.TransactionFeeStationWalletSource = nil
			return fmt.Errorf("failed to unmarshal TransactionSource as TransactionFeeStationWalletSource: %s", err.Error())
		}
	}

	// check if the discriminator value is 'MPCWallet'
	if jsonDict["source_type"] == "MPCWallet" {
		// try to unmarshal JSON data into TransactionMPCWalletSource
		err = json.Unmarshal(data, &dst.TransactionMPCWalletSource)
		if err == nil {
			return nil // data stored in dst.TransactionMPCWalletSource, return on the first match
		} else {
			dst.TransactionMPCWalletSource = nil
			return fmt.Errorf("failed to unmarshal TransactionSource as TransactionMPCWalletSource: %s", err.Error())
		}
	}

	// check if the discriminator value is 'SafeWallet'
	if jsonDict["source_type"] == "SafeWallet" {
		// try to unmarshal JSON data into TransactionSafeWalletSource
		err = json.Unmarshal(data, &dst.TransactionSafeWalletSource)
		if err == nil {
			return nil // data stored in dst.TransactionSafeWalletSource, return on the first match
		} else {
			dst.TransactionSafeWalletSource = nil
			return fmt.Errorf("failed to unmarshal TransactionSource as TransactionSafeWalletSource: %s", err.Error())
		}
	}

	// check if the discriminator value is 'TransactionAddressSource'
	if jsonDict["source_type"] == "TransactionAddressSource" {
		// try to unmarshal JSON data into TransactionAddressSource
		err = json.Unmarshal(data, &dst.TransactionAddressSource)
		if err == nil {
			return nil // data stored in dst.TransactionAddressSource, return on the first match
		} else {
			dst.TransactionAddressSource = nil
			return fmt.Errorf("failed to unmarshal TransactionSource as TransactionAddressSource: %s", err.Error())
		}
	}

	// check if the discriminator value is 'TransactionCustodialWalletSource'
	if jsonDict["source_type"] == "TransactionCustodialWalletSource" {
		// try to unmarshal JSON data into TransactionCustodialWalletSource
		err = json.Unmarshal(data, &dst.TransactionCustodialWalletSource)
		if err == nil {
			return nil // data stored in dst.TransactionCustodialWalletSource, return on the first match
		} else {
			dst.TransactionCustodialWalletSource = nil
			return fmt.Errorf("failed to unmarshal TransactionSource as TransactionCustodialWalletSource: %s", err.Error())
		}
	}

	// check if the discriminator value is 'TransactionExchangeWalletSource'
	if jsonDict["source_type"] == "TransactionExchangeWalletSource" {
		// try to unmarshal JSON data into TransactionExchangeWalletSource
		err = json.Unmarshal(data, &dst.TransactionExchangeWalletSource)
		if err == nil {
			return nil // data stored in dst.TransactionExchangeWalletSource, return on the first match
		} else {
			dst.TransactionExchangeWalletSource = nil
			return fmt.Errorf("failed to unmarshal TransactionSource as TransactionExchangeWalletSource: %s", err.Error())
		}
	}

	// check if the discriminator value is 'TransactionFeeStationWalletSource'
	if jsonDict["source_type"] == "TransactionFeeStationWalletSource" {
		// try to unmarshal JSON data into TransactionFeeStationWalletSource
		err = json.Unmarshal(data, &dst.TransactionFeeStationWalletSource)
		if err == nil {
			return nil // data stored in dst.TransactionFeeStationWalletSource, return on the first match
		} else {
			dst.TransactionFeeStationWalletSource = nil
			return fmt.Errorf("failed to unmarshal TransactionSource as TransactionFeeStationWalletSource: %s", err.Error())
		}
	}

	// check if the discriminator value is 'TransactionMPCWalletSource'
	if jsonDict["source_type"] == "TransactionMPCWalletSource" {
		// try to unmarshal JSON data into TransactionMPCWalletSource
		err = json.Unmarshal(data, &dst.TransactionMPCWalletSource)
		if err == nil {
			return nil // data stored in dst.TransactionMPCWalletSource, return on the first match
		} else {
			dst.TransactionMPCWalletSource = nil
			return fmt.Errorf("failed to unmarshal TransactionSource as TransactionMPCWalletSource: %s", err.Error())
		}
	}

	// check if the discriminator value is 'TransactionSafeWalletSource'
	if jsonDict["source_type"] == "TransactionSafeWalletSource" {
		// try to unmarshal JSON data into TransactionSafeWalletSource
		err = json.Unmarshal(data, &dst.TransactionSafeWalletSource)
		if err == nil {
			return nil // data stored in dst.TransactionSafeWalletSource, return on the first match
		} else {
			dst.TransactionSafeWalletSource = nil
			return fmt.Errorf("failed to unmarshal TransactionSource as TransactionSafeWalletSource: %s", err.Error())
		}
	}

	return nil
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src TransactionSource) MarshalJSON() ([]byte, error) {
	if src.TransactionAddressSource != nil {
		return json.Marshal(&src.TransactionAddressSource)
	}

	if src.TransactionCustodialWalletSource != nil {
		return json.Marshal(&src.TransactionCustodialWalletSource)
	}

	if src.TransactionExchangeWalletSource != nil {
		return json.Marshal(&src.TransactionExchangeWalletSource)
	}

	if src.TransactionFeeStationWalletSource != nil {
		return json.Marshal(&src.TransactionFeeStationWalletSource)
	}

	if src.TransactionMPCWalletSource != nil {
		return json.Marshal(&src.TransactionMPCWalletSource)
	}

	if src.TransactionSafeWalletSource != nil {
		return json.Marshal(&src.TransactionSafeWalletSource)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *TransactionSource) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.TransactionAddressSource != nil {
		return obj.TransactionAddressSource
	}

	if obj.TransactionCustodialWalletSource != nil {
		return obj.TransactionCustodialWalletSource
	}

	if obj.TransactionExchangeWalletSource != nil {
		return obj.TransactionExchangeWalletSource
	}

	if obj.TransactionFeeStationWalletSource != nil {
		return obj.TransactionFeeStationWalletSource
	}

	if obj.TransactionMPCWalletSource != nil {
		return obj.TransactionMPCWalletSource
	}

	if obj.TransactionSafeWalletSource != nil {
		return obj.TransactionSafeWalletSource
	}

	// all schemas are nil
	return nil
}

type NullableTransactionSource struct {
	value *TransactionSource
	isSet bool
}

func (v NullableTransactionSource) Get() *TransactionSource {
	return v.value
}

func (v *NullableTransactionSource) Set(val *TransactionSource) {
	v.value = val
	v.isSet = true
}

func (v NullableTransactionSource) IsSet() bool {
	return v.isSet
}

func (v *NullableTransactionSource) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTransactionSource(val *TransactionSource) *NullableTransactionSource {
	return &NullableTransactionSource{value: val, isSet: true}
}

func (v NullableTransactionSource) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTransactionSource) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


